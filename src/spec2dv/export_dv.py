# src/spec2dv/export_dv.py
from __future__ import annotations

import json
from pathlib import Path
import sqlite3


def export_dv_constraints_json(conn: sqlite3.Connection, out_path: Path) -> None:
    """
    Minimal DV constraints:
    - enumerated legal values per field
    - reserved fields: if name is RSVD, mark MUST_BE_ZERO
    """
    out = {"fields": {}, "reserved_policy": "READS_AS_ZERO_WRITES_IGNORED"}

    rows = conn.execute(
        """
        SELECT b.name AS block_name, r.name AS reg_name, f.id AS field_id, f.name AS field_name
        FROM field f
        JOIN reg r ON r.id=f.reg_id
        JOIN ip_block b ON b.id=r.block_id
        ORDER BY b.name, r.name, f.name
        """
    ).fetchall()

    for row in rows:
        key = f"{row['block_name']}.{row['reg_name']}.{row['field_name']}"
        if row["field_name"].upper() in {"RSVD", "RESERVED"}:
            out["fields"][key] = {"reserved": True}
            continue

        enums = conn.execute(
            "SELECT name, value FROM enum_value WHERE field_id=? ORDER BY value",
            (row["field_id"],),
        ).fetchall()
        if enums:
            out["fields"][key] = {"legal_enum": [{"name": e["name"], "value": e["value"]} for e in enums]}

    out_path.write_text(json.dumps(out, indent=2), encoding="utf-8")


def export_uvm_regmodel(conn: sqlite3.Connection, out_path: Path) -> None:
    """
    Generates a lightweight SystemVerilog stub showing that the spec can drive a UVM-RAL style model.
    This is NOT a full UVM reg model; it's intentionally minimal and recruiter-friendly.
    """
    lines = []
    lines.append("// Auto-generated by Spec2DV")
    lines.append("// Minimal UVM register model stubs (skeleton)")
    lines.append("")
    lines.append("`ifndef SPEC2DV_UVM_REGMODEL_SV")
    lines.append("`define SPEC2DV_UVM_REGMODEL_SV")
    lines.append("")
    lines.append("// NOTE: Requires UVM in a real environment.")
    lines.append("// import uvm_pkg::*; `include \"uvm_macros.svh\"")
    lines.append("")

    blocks = conn.execute("SELECT id, name FROM ip_block ORDER BY name").fetchall()

    for b in blocks:
        regs = conn.execute(
            "SELECT id, name, offset, width FROM reg WHERE block_id=? ORDER BY offset",
            (b["id"],),
        ).fetchall()

        for r in regs:
            cls = f"{b['name']}_{r['name']}".lower()
            lines.append(f"// {b['name']}.{r['name']} @ offset {hex(r['offset'])}")
            lines.append(f"class {cls}; // extends uvm_reg")
            lines.append("  // uvm_reg_field fields[$];")
            lines.append("  function void build();")
            fields = conn.execute(
                "SELECT name, lsb, msb, access, reset FROM field WHERE reg_id=? ORDER BY lsb",
                (r["id"],),
            ).fetchall()
            for f in fields:
                width = (f["msb"] - f["lsb"]) + 1
                lines.append(
                    f"    // {f['name']} [{f['msb']}:{f['lsb']}] access={f['access']} reset={f['reset']} width={width}"
                )
            lines.append("  endfunction")
            lines.append("endclass")
            lines.append("")

    lines.append("`endif")
    out_path.write_text("\n".join(lines), encoding="utf-8")